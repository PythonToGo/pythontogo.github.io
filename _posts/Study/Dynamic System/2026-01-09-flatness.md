---
title: Flatness
description: Summary of Flatness
date: 2026-01-09 11:00:00
categories: [Study, Dynamic System]
author: PythonToGo
tags: [Dynamic System, Flatness, Flat Systems, Heuristic, Flatness-Based]
# pin: true
math: true
mermaid: true
comments: true
image: 
#     # type: pdf
    path: assets/img/posts/study-ds/ch8_front.png

#     # page: 7
#     alt: 
---
{% include pdf-viewer.html %}

# 들어가기 전에... 왜 비선형 시스템은 이렇게 어려울까?

> **How can we design controllers that are exact, predictable, and robust over a wide operating range without the limitations of local approximations?**

크게 3가지 정도로 특징을 뽑을 수 있는데 -  **Complex dynamics**, **local vs. galobal validity**, **hidden internal dynamics** 정도로 볼 수 있다. 간단하게 말하면 비정형적인 행동양상과, 유효한 범위의 문제와, 그 밖의 노이즈 등에 의해 컨트롤하기 어렵다 - 이다. 


<div class="pdf-viewer-container" data-pdf="/assets/img/posts/study-ds/ds8.pdf" data-page="2"></div>


그럼 여기서 우리는 이런 질문을 할 수 있다. 만약에 그런 모든 것을 다 설명할 수 있는 어떤 임의의 무언가를 찾으면?



이 질문의 답이 바로 Flat!

<div class="pdf-viewer-container" data-pdf="/assets/img/posts/study-ds/ds8.pdf" data-page="3"></div>


# Flatness

**Flatness**는 non-linear system이 적절한 coordinate transformation을 통해 선형공간에서의 linear system으로 표현될 수 있다는 개념에서 출발하고, 특히 시스템의 Controllability(가도달성)과 Trajectory Planning(궤적 계획)과 밀접한 관련이 있다. 

약간 추상명사처럼 모든 조건을 다 만족할때를 표현한 임의의 세계이다. 

## Flat Systems


### Flatness Definition

어떤 시스템 $$\dot{x} = f(x, u)$$ 와 출력 $$y = \Psi_y (x, u, \dot{u}, ..., u^{(\alpha)})$$ 에 대해 $$\text{dim}(y) = \text{dim}(u)$$ 를 만족할때, 다음의 유일한 표현식이 존재하면 이 시스템을 **Differentially Flat**하다고 정의한다.

- **State Variables** : $$x = \left( y, \dot{y}, ... , y^{(\gamma - 1)} \right)$$
- **Input Variables** : $$u = \Psi_u \left( y, \dot{y}, ... , y^{(\gamma)} \right)$$

여기서 $$\alpha$$ 와 $$\gamma$$ 는 유한한 미분 횟수를 의미한다. 시스템의 모든 변수가 **Flat Output $$y$$** 에 의해 결정되기때문에, 이를 **시스템이 $$y$$ 에 의해 Parameterized** 되었다고 한다.

> ## Flatness
>
> The system $$\dot{x} = f(x, u)$$ with output $$y= \Psi_y (x, u, \dot{u}, ..., u^{(\alpha)})$$ and $$\text{dim}(y) = \text{dim}(y)$$ is **flat**, if the following unique representations of $x$ and $u$ exist:
>
> - $$x = \Psi_x \left( y, \dot{y}, ... , y^{(\gamma - 1)} \right)$$
> - $$u = \Psi_u \left( y, \dot{y}, ... , y^{(\gamma)} \right)$$
>
> with $$\alpha, \gamma < \infty$$ (finite numbers of derivatives).
>
>
> $$\rightarrow$$ The output $$y$$ is then called a **flat output**.
{: .prompt-tip}


### Eigenschaften

- **Controllability and Reachability** : 모든 Flat System은 두 가지를 모두 가진다.
- **Linearization** : 이런 시스템은 **Static** 또는 **Dynamic State Feedback**을 통해 항상 선형화 될 수 있다.
- **Equilibria Analysis** : 평형점(EP) $$x^*, u^*$$ 를 구할 때, 복잡한 방정식을 풀 필요 없이, $$y = y*$$ 이고, 그 이상의 미분항이 0이라는 조건만으로 $$x^* = \tilde{\Psi}_1(y^*), u^* = \tilde{\Psi}_2(y^*) $$ 와 같이 쉽게 파라미터화 할 수 있다. 


## Flatness Analysis - 시스템 분석 및 출력 결정

시스템이 flat한지 판단하는 일반적인 필요충분조건은 아직 없다(!). 하지만 주로 Heuristic 기법을 사용한다. (~~사실 휴리스틱은 그냥 어찌저찌해서 노가다해보니 뭔가 맞았다 의 느낌이 강하다. 경험치느낌쓰~~)

![Heuristic](assets/img/posts/study-ds/ds8_heuristic.png)

### How to select and validate Flat Output Candidate

1. 시스템의 dynamic behavior에 대해 가장 많은 정보를 담고 있는 물리적인 변수를 **Flat Output 의 후보 $y$**로 선택한다.
2. 후보 $y$를 시간에 대해 계속 미분해서, 상태/State $x_j$ 와 입력 $u_i$ 를 $y$ 와 그 미분항들로만 구성된 non-linear 방정식으로 유도한다.
3. 입력 $u$ 가 나타나기 전까지 미분을 많이 수행할 수 있는 output이 *좋은* 후보이다.


> #### A Heurictic Procedure
>
> **1. Select a Candidate $y$** : Choose a potential output that seems to capture the essential motion or information of the system. $$dim(y) = dim(u)$$
>
> **2. Differentiate Successively** : Calculate  the time derivatives $$\dot{y}, \ddot{y}, ...$$ using the system's state euqtions $$\dot{x} = f(x, u)$$.
>
> **3. Check for Invertibility** : At each step, check if the resulting system of algebraic equations can be inverted to express all states $$x$$ and inputs $$u$$ in terms of $$y$$ and its derivatives alone.
>
> **4. Confirm** : If all states and inputs can be uniquely determined, the candidate $$y$$ is a flat output.
{: .prompt-info}


### 

실제 시스템에서 Flat Output 을 어떻게 설정하고, 이걸 가지고 시스템의 State, Input을 어떻게 *parameterization* 하는지 케이스를 통해 알아보자. 

![Kinematic Vehicle](assets/img/posts/study-ds/ds8_kin-vec.png)

다음은 두 개의 차축을 가진 차(Two axle vehicle)이다. 이 시스템을 모델링 해보자. 


#### State equations

**State**

$$ \dot{x_1} = u_1 \  cos \ x_3 $$

$$ \dot{x_2} = u_1 \  sin \ x_3 $$

$$ \dot{x_3} = u_1 \  tan \ x_3 $$


**Variables**

$$(x_1, x_2)$$ : 차의 뒷축 중심점 $$P$$ 의 좌표

$$x_3$$ : 차의 방향

$$u_1$$ : 차의 속도

$$u_2$$ : 차의 Steering angle


#### Selection of Flat Output

**Flatness Analysis** 의 핵심은 시스템의 *모든(!)* 정보를 담고 있는 출력 $$y$$ 를 찾는것이다. 여기서는 뒷축 중심점 $$P$$ 의 좌표를 **Flat Output** 후보로 선택한다. 

$$y = [x_1, x_2]^T$$

#### Verfication - Derivation and Parameterization

선택한 $$y$$ 가 Flat output인지 확인하기 위해, $$y$$ 를 시간에 대해 미분해서 State $$x$$, Input $$u$$ 의 $$y$$ 의 미분항들로 표현한다.


- **1st Derivate $$\dot{y}$$**

    $$\dot{y_1} = \dot{x_1} = u_1 \ cos \ x_3$$

    $$\dot{y_2} = \dot{x_2} = u_1 sin \ x_3$$


    이 식으로부터 방향 $$x_3 = \text{arctan} \frac{\dot{y_2}}{\dot{y_1}}$$ 을 구할 수 있고, 속도  $$u_1 = \frac{\dot{y_1}}{\dot{y_1}}$$ 도 $$y$$ 의 미분으로 표현할수 있다. 

- **2nd Derivate $$\dot{y}$$**

    $$\dot{y_1}$$ 와 $$\ddot{y_2}$$ 를 구하는 과정에서 Steering angle $$u_2$$ 과 input의 미분 $$\dot{u_1}$$ 이 나오며, 결과적으로 이렇게 했을때, 모든 상태 변수와 입력 변수를 $$y, \dot{y}, \ddot{y}$$ 의 함수로 유일하게 나타낼 수 있다.  


$$
\left\{
\begin{aligned}
y_1 &= x_1 \\
y_2 &= x_2 \\
\dot{y}_1 &= u_1 \cos x_3 \\
\dot{y}_2 &= u_1 \sin x_3 \\
\ddot{y}_1 &= \dot{u}_1 \cos x_3 - u_1^2 \tan u_2 \sin x_3 \\
\ddot{y}_2 &= \dot{u}_1 \sin x_3 + u_1^2 \tan u_2 \cos x_3
\end{aligned}
\right.
\quad \leftrightarrow \quad
\left\{
\begin{aligned}
x_1 &= y_1 \\
x_2 &= y_2 \\
x_3 &= \arctan \frac{\dot{y}_2}{\dot{y}_1} \\
u_1 &= \frac{\dot{y}_1}{\cos\left(\arctan \frac{\dot{y}_2}{\dot{y}_1}\right)} \\
u_2 &= \Psi_1\left(y_1, y_2, \dot{y}_1, \frac{\dot{y}_2}{\dot{y}_1}, \ddot{y}_1, \ddot{y}_2\right) \\
\dot{u}_1 &= \Psi_2\left(y_1, y_2, \dot{y}_1, \frac{\dot{y}_2}{\dot{y}_1}, \ddot{y}_1, \ddot{y}_2\right)
\end{aligned}
\right.
$$

#### Analysis Conclusion

1. 상태 $$x$$ 와 입력 $$u$$ 가 $$y$$ 와 그 미분항($$\gamma = 2$$ 차까지)으로 완전히 결정되고, 이 시스템은 **differentially flat**하며 $$y = [x_1, x_2]^T$$ 는 유효한 **Flat Output** 이다.
2. 이렇게 전개된 관계식은 $$\dot{y_1} = 0$$ 인 지점과 같은 특정 Singulairites를 제외한 영역에서 locally valid 하다.



하지만 이런 일련의 과정들이 매우복잡한 계산일 수 있어서 여러 프로그램을 사용한다. MATHEMATICA, MAPLE, ... etc 


---

### Flatness-Based Feedforward Control - 개루프 궤적 추종 제어

한국어로 쓰니까 너무 어렵네.. 

암튼 시스템이 flat 하다면, target trajectory $$y_d (t)$$ 를 트래킹하기 위한 입력을 **Inverse System** 을 통해 직접 계산할 수 있다. 

<div class="pdf-viewer-container" data-pdf="/assets/img/posts/study-ds/ds8.pdf" data-page="7"></div>


###  Target Trajectory Generation - 3 Types

Control input 을 설계하기 전에, target trajectory 를 생성해야 되고, source에서는 이를 다음 3가지로 분류한다. 


- Case 1: target trajectory $$y_d (t)$$ 자체가 충분히 *미분 가능한* 형태로 주어지는 경우.
- Case 2: target trajectory 가 $$y$$ 가 아닌 다른 제어 변수 $$w_d (t)$$ 에 대해 주어지는 경우  (-> 이 경우는 수치적인 적분이 필요하다)
- Case 3: initial state $$x_d(0)$$, final state $$x_d(t_f)$$ 만 주어지고, 그 사이를 곡선 등으로 연결하는 경우. 


#### Case 1 - Flat Output에 대한 직접적인 정의

target trajectory $$y_d(t), t \in [0, t_f]$$ 가 flat output 자체에 대해 충분히 **미분 가능한 시간 함수**로 주어지는 경우이다. 이 경우, 아래 관계식을 통해 제어 함수 $$u_d (t)$$ 를 즉시 결정할 수 있다. (쉬운편)

$$
u = \Psi_2 (y, \dot{y}, \ddot{y}, ... y^{(\gamma)})
$$


#### Case 2 - w.r.t. $$w_d(t)$$

target trajectory 가  float output 이 아닌 다른 제어변수 $$w_d (t) = \eta (x)$$ 로 정의 되는 경우이다. 단 $$\text{dim}(w) = m$$ 이다. 이때 $$w$$ 와 $$y$$ 의 관계인 

$$
w_d = \eta (\Psi_1 (y_d, \dot{y_d}, ..., y_d^{(\gamma - 1)}))
$$

로 부터 $$y_d$$ 에 대한 Implicit Differential Equation 을 유도하게 된다. 이 방정식은 numerical integration 을 통해 풀고, $$ y_d$$ 를 구하는 것이 목적이 됨.


#### Case 3 - value only initial and final state

target trajectory 가 initial state $$x_d (0)$$ 와 final state $$x_d(t_f)$$ 로만 정의된 경우이다. 이때 이 상태값들을 flat output 으로 변환하면 $$ y_d (0)$$ , $$ y_d(t_f)$$ 를 계산할 수 있다. 그리고 그 사이를 충분히 미분 가능한 곡선인 **Splines** or **Polynomials** 등으로 부드러운 곡선을 사용해 연결해서 trajectory 를 만든다. 



이 파트는 이론적인것보다 문제를 몇 가지 풀어보는게 더 나을듯하다. 


### Control Law Generation - 제어법칙의 도출 및 구조

위의 3가지 케이스 중 하나로 어찌저찌 target trajectory $$y_d (t)$$ 를 구했다고 가정한다. 그 다음엔 시스템의 모든 변수를 이 trajectory 와 그 미분항들로 parameterized 가능하다. 


> #### State and Input 
>
> $$x_d = \Psi_1 (y_d(t), \dot{y_d}(t), ..., y^{(\gamma - 1)_d}) $$
>
> $$y_d = \Psi_2 (y_d(t), \dot{y_d}(t), ..., y^{(\gamma)_d}) $$
>
{: .prompt-info}

그 다음 계산된 $$u_d (t)$$ 를 Open Loop 형태로 시스템에 직접 넣는다. 이는 inverse system 을 통해 원하는 **출력(output)** 으로부터 **입력(input)** 을 뽑아내, 실제 시스템에 넣어주는 구조이다. 



### limitations...

단, 다음 전제 조건이 충족되어야함.

1. 제어할 System 이 Stable 해야함
2. Initial values 를 정확히 알고 있어야, 오차 없이 trajectory 따라갈 수 있음
3. Disturbances 가 매우 작아야 함. 노이즈가 크면 feedforward 만드로는 한계가 있음. 이 경우, feedback control 을 해야하는데, 이것은 다음 포스팅에 !



<div class="pdf-viewer-container" data-pdf="/assets/img/posts/study-ds/ds8.pdf" data-page="9"></div>